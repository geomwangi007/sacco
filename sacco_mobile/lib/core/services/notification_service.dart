import 'dart:convert';\nimport 'dart:io';\n\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:flutter_local_notifications/flutter_local_notifications.dart';\nimport 'package:injectable/injectable.dart';\nimport 'package:logger/logger.dart';\nimport 'package:rxdart/rxdart.dart';\n\nimport '../storage/secure_storage_service.dart';\nimport '../constants/storage_keys.dart';\nimport '../../app/app_config.dart';\n\n@lazySingleton\nclass NotificationService {\n  final FirebaseMessaging _firebaseMessaging;\n  final FlutterLocalNotificationsPlugin _localNotifications;\n  final SecureStorageService _secureStorage;\n  final Logger _logger;\n\n  // Stream controllers for notification events\n  final _notificationClickedSubject = BehaviorSubject<Map<String, dynamic>>();\n  final _fcmTokenSubject = BehaviorSubject<String>();\n\n  NotificationService(\n    this._firebaseMessaging,\n    this._localNotifications,\n    this._secureStorage,\n    this._logger,\n  );\n\n  // Getters for streams\n  Stream<Map<String, dynamic>> get onNotificationClicked =>\n      _notificationClickedSubject.stream;\n  Stream<String> get onFcmTokenRefresh => _fcmTokenSubject.stream;\n\n  /// Initialize notification service\n  Future<void> initialize() async {\n    if (!AppConfig.enablePushNotifications) {\n      _logger.i('Push notifications disabled by config');\n      return;\n    }\n\n    try {\n      await _initializeLocalNotifications();\n      await _initializeFirebaseMessaging();\n      _logger.i('Notification service initialized successfully');\n    } catch (e) {\n      _logger.e('Error initializing notification service: $e');\n      rethrow;\n    }\n  }\n\n  /// Initialize local notifications\n  Future<void> _initializeLocalNotifications() async {\n    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');\n    const iosSettings = DarwinInitializationSettings(\n      requestAlertPermission: true,\n      requestBadgePermission: true,\n      requestSoundPermission: true,\n    );\n\n    const initSettings = InitializationSettings(\n      android: androidSettings,\n      iOS: iosSettings,\n    );\n\n    await _localNotifications.initialize(\n      initSettings,\n      onDidReceiveNotificationResponse: _onNotificationTapped,\n    );\n\n    // Create notification channels for Android\n    if (Platform.isAndroid) {\n      await _createNotificationChannels();\n    }\n  }\n\n  /// Create notification channels for different types\n  Future<void> _createNotificationChannels() async {\n    const channels = [\n      AndroidNotificationChannel(\n        'transaction_alerts',\n        'Transaction Alerts',\n        description: 'Notifications for transaction activities',\n        importance: Importance.high,\n        sound: RawResourceAndroidNotificationSound('transaction_sound'),\n      ),\n      AndroidNotificationChannel(\n        'loan_updates',\n        'Loan Updates',\n        description: 'Notifications for loan status updates',\n        importance: Importance.high,\n      ),\n      AndroidNotificationChannel(\n        'payment_reminders',\n        'Payment Reminders',\n        description: 'Reminders for upcoming payments',\n        importance: Importance.high,\n      ),\n      AndroidNotificationChannel(\n        'security_alerts',\n        'Security Alerts',\n        description: 'Important security notifications',\n        importance: Importance.max,\n        sound: RawResourceAndroidNotificationSound('security_alert'),\n      ),\n      AndroidNotificationChannel(\n        'general_updates',\n        'General Updates',\n        description: 'General SACCO updates and announcements',\n        importance: Importance.defaultImportance,\n      ),\n    ];\n\n    for (final channel in channels) {\n      await _localNotifications\n          .resolvePlatformSpecificImplementation<\n              AndroidFlutterLocalNotificationsPlugin>()\n          ?.createNotificationChannel(channel);\n    }\n  }\n\n  /// Initialize Firebase messaging\n  Future<void> _initializeFirebaseMessaging() async {\n    // Request permission\n    await requestPermission();\n\n    // Get FCM token\n    final token = await _firebaseMessaging.getToken();\n    if (token != null) {\n      await _storeFcmToken(token);\n      _fcmTokenSubject.add(token);\n    }\n\n    // Listen for token refresh\n    _firebaseMessaging.onTokenRefresh.listen((token) {\n      _storeFcmToken(token);\n      _fcmTokenSubject.add(token);\n      _logger.i('FCM token refreshed');\n    });\n\n    // Handle foreground messages\n    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);\n\n    // Handle background message taps\n    FirebaseMessaging.onMessageOpenedApp.listen(_handleBackgroundMessageTap);\n\n    // Handle app launch from terminated state\n    final initialMessage = await _firebaseMessaging.getInitialMessage();\n    if (initialMessage != null) {\n      _handleBackgroundMessageTap(initialMessage);\n    }\n  }\n\n  /// Request notification permissions\n  Future<bool> requestPermission() async {\n    try {\n      final settings = await _firebaseMessaging.requestPermission(\n        alert: true,\n        badge: true,\n        sound: true,\n        carPlay: false,\n        criticalAlert: false,\n        provisional: false,\n        announcement: false,\n      );\n\n      final granted = settings.authorizationStatus == AuthorizationStatus.authorized ||\n          settings.authorizationStatus == AuthorizationStatus.provisional;\n\n      await _secureStorage.write(\n        StorageKeys.notificationPermissionGranted,\n        granted.toString(),\n      );\n\n      _logger.i('Notification permission status: ${settings.authorizationStatus}');\n      return granted;\n    } catch (e) {\n      _logger.e('Error requesting notification permission: $e');\n      return false;\n    }\n  }\n\n  /// Check if notification permission is granted\n  Future<bool> isPermissionGranted() async {\n    try {\n      final granted = await _secureStorage.read(\n        StorageKeys.notificationPermissionGranted,\n      );\n      return granted == 'true';\n    } catch (e) {\n      _logger.e('Error checking notification permission: $e');\n      return false;\n    }\n  }\n\n  /// Get FCM token\n  Future<String?> getFcmToken() async {\n    try {\n      return await _secureStorage.read(StorageKeys.fcmToken);\n    } catch (e) {\n      _logger.e('Error getting FCM token: $e');\n      return null;\n    }\n  }\n\n  /// Store FCM token\n  Future<void> _storeFcmToken(String token) async {\n    try {\n      await _secureStorage.write(StorageKeys.fcmToken, token);\n      _logger.i('FCM token stored');\n    } catch (e) {\n      _logger.e('Error storing FCM token: $e');\n    }\n  }\n\n  /// Handle foreground messages\n  void _handleForegroundMessage(RemoteMessage message) {\n    _logger.i('Received foreground message: ${message.messageId}');\n    \n    // Show local notification\n    _showLocalNotification(\n      title: message.notification?.title ?? 'SACCO',\n      body: message.notification?.body ?? 'You have a new notification',\n      payload: jsonEncode(message.data),\n      channelId: _getChannelId(message.data['type']),\n    );\n  }\n\n  /// Handle background message tap\n  void _handleBackgroundMessageTap(RemoteMessage message) {\n    _logger.i('Background message tapped: ${message.messageId}');\n    _notificationClickedSubject.add(message.data);\n  }\n\n  /// Handle local notification tap\n  void _onNotificationTapped(NotificationResponse response) {\n    _logger.i('Local notification tapped: ${response.id}');\n    \n    if (response.payload != null) {\n      try {\n        final data = jsonDecode(response.payload!) as Map<String, dynamic>;\n        _notificationClickedSubject.add(data);\n      } catch (e) {\n        _logger.e('Error parsing notification payload: $e');\n      }\n    }\n  }\n\n  /// Show local notification\n  Future<void> _showLocalNotification({\n    required String title,\n    required String body,\n    String? payload,\n    String channelId = 'general_updates',\n    int? id,\n  }) async {\n    try {\n      final notificationId = id ?? DateTime.now().millisecondsSinceEpoch.remainder(100000);\n      \n      const androidDetails = AndroidNotificationDetails(\n        'general_updates',\n        'General Updates',\n        channelDescription: 'General SACCO updates and announcements',\n        importance: Importance.high,\n        priority: Priority.high,\n        ticker: 'SACCO',\n      );\n      \n      const iosDetails = DarwinNotificationDetails(\n        presentAlert: true,\n        presentBadge: true,\n        presentSound: true,\n      );\n      \n      const details = NotificationDetails(\n        android: androidDetails,\n        iOS: iosDetails,\n      );\n      \n      await _localNotifications.show(\n        notificationId,\n        title,\n        body,\n        details,\n        payload: payload,\n      );\n    } catch (e) {\n      _logger.e('Error showing local notification: $e');\n    }\n  }\n\n  /// Get appropriate channel ID based on notification type\n  String _getChannelId(String? type) {\n    switch (type) {\n      case 'transaction':\n        return 'transaction_alerts';\n      case 'loan':\n        return 'loan_updates';\n      case 'payment_reminder':\n        return 'payment_reminders';\n      case 'security':\n        return 'security_alerts';\n      default:\n        return 'general_updates';\n    }\n  }\n\n  /// Show transaction notification\n  Future<void> showTransactionNotification({\n    required String title,\n    required String body,\n    required Map<String, dynamic> data,\n  }) async {\n    await _showLocalNotification(\n      title: title,\n      body: body,\n      payload: jsonEncode(data),\n      channelId: 'transaction_alerts',\n    );\n  }\n\n  /// Show loan update notification\n  Future<void> showLoanUpdateNotification({\n    required String title,\n    required String body,\n    required Map<String, dynamic> data,\n  }) async {\n    await _showLocalNotification(\n      title: title,\n      body: body,\n      payload: jsonEncode(data),\n      channelId: 'loan_updates',\n    );\n  }\n\n  /// Show payment reminder notification\n  Future<void> showPaymentReminderNotification({\n    required String title,\n    required String body,\n    required Map<String, dynamic> data,\n  }) async {\n    await _showLocalNotification(\n      title: title,\n      body: body,\n      payload: jsonEncode(data),\n      channelId: 'payment_reminders',\n    );\n  }\n\n  /// Show security alert notification\n  Future<void> showSecurityAlertNotification({\n    required String title,\n    required String body,\n    required Map<String, dynamic> data,\n  }) async {\n    await _showLocalNotification(\n      title: title,\n      body: body,\n      payload: jsonEncode(data),\n      channelId: 'security_alerts',\n    );\n  }\n\n  /// Schedule a notification\n  Future<void> scheduleNotification({\n    required int id,\n    required String title,\n    required String body,\n    required DateTime scheduledDate,\n    String? payload,\n    String channelId = 'payment_reminders',\n  }) async {\n    try {\n      const androidDetails = AndroidNotificationDetails(\n        'payment_reminders',\n        'Payment Reminders',\n        channelDescription: 'Reminders for upcoming payments',\n        importance: Importance.high,\n        priority: Priority.high,\n      );\n      \n      const iosDetails = DarwinNotificationDetails(\n        presentAlert: true,\n        presentBadge: true,\n        presentSound: true,\n      );\n      \n      const details = NotificationDetails(\n        android: androidDetails,\n        iOS: iosDetails,\n      );\n      \n      await _localNotifications.zonedSchedule(\n        id,\n        title,\n        body,\n        scheduledDate,\n        details,\n        payload: payload,\n        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,\n        uiLocalNotificationDateInterpretation:\n            UILocalNotificationDateInterpretation.absoluteTime,\n      );\n      \n      _logger.i('Notification scheduled for: $scheduledDate');\n    } catch (e) {\n      _logger.e('Error scheduling notification: $e');\n    }\n  }\n\n  /// Cancel a scheduled notification\n  Future<void> cancelNotification(int id) async {\n    try {\n      await _localNotifications.cancel(id);\n      _logger.i('Notification cancelled: $id');\n    } catch (e) {\n      _logger.e('Error cancelling notification: $e');\n    }\n  }\n\n  /// Cancel all notifications\n  Future<void> cancelAllNotifications() async {\n    try {\n      await _localNotifications.cancelAll();\n      _logger.i('All notifications cancelled');\n    } catch (e) {\n      _logger.e('Error cancelling all notifications: $e');\n    }\n  }\n\n  /// Subscribe to topic\n  Future<void> subscribeToTopic(String topic) async {\n    try {\n      await _firebaseMessaging.subscribeToTopic(topic);\n      _logger.i('Subscribed to topic: $topic');\n    } catch (e) {\n      _logger.e('Error subscribing to topic $topic: $e');\n    }\n  }\n\n  /// Unsubscribe from topic\n  Future<void> unsubscribeFromTopic(String topic) async {\n    try {\n      await _firebaseMessaging.unsubscribeFromTopic(topic);\n      _logger.i('Unsubscribed from topic: $topic');\n    } catch (e) {\n      _logger.e('Error unsubscribing from topic $topic: $e');\n    }\n  }\n\n  /// Clear all notification data (e.g., on logout)\n  Future<void> clearNotificationData() async {\n    try {\n      await _secureStorage.delete(StorageKeys.fcmToken);\n      await _secureStorage.delete(StorageKeys.notificationPermissionGranted);\n      await cancelAllNotifications();\n      _logger.i('Notification data cleared');\n    } catch (e) {\n      _logger.e('Error clearing notification data: $e');\n    }\n  }\n\n  /// Dispose resources\n  void dispose() {\n    _notificationClickedSubject.close();\n    _fcmTokenSubject.close();\n  }\n}